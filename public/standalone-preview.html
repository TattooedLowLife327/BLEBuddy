import { useState, useCallback, useEffect } from 'react';

// Dart Simulator Panel for demo/preview mode
function DartSimulator({ onThrow, disabled }: { onThrow: (segment: string, score: number, multiplier: number) => void; disabled: boolean }) {
  const [multiplierMode, setMultiplierMode] = useState<'single' | 'double' | 'triple'>('single');
  const [expanded, setExpanded] = useState(true);

  const handleNumberClick = (num: number) => {
    if (disabled) return;
    const mult = multiplierMode === 'triple' ? 3 : multiplierMode === 'double' ? 2 : 1;
    const prefix = multiplierMode === 'triple' ? 'T' : multiplierMode === 'double' ? 'D' : 'S';
    onThrow(`${prefix}${num}`, num * mult, mult);
  };

  const handleBullClick = (isDouble: boolean) => {
    if (disabled) return;
    if (isDouble) {
      onThrow('D25', 50, 2);
    } else {
      onThrow('S25', 25, 1);
    }
  };

  const handleMissClick = () => {
    if (disabled) return;
    onThrow('MISS', 0, 0);
  };

  // Dartboard number order (clockwise starting from 20 at top)
  const dartboardOrder = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

  return (
    <div style={{
      position: 'fixed',
      bottom: expanded ? 0 : '-220px',
      left: '50%',
      transform: 'translateX(-50%)',
      width: '600px',
      maxWidth: '90vw',
      background: 'rgba(0, 0, 0, 0.9)',
      backdropFilter: 'blur(12px)',
      borderTopLeftRadius: '16px',
      borderTopRightRadius: '16px',
      border: '1px solid rgba(255, 255, 255, 0.2)',
      borderBottom: 'none',
      padding: '12px 16px 16px',
      zIndex: 500,
      transition: 'bottom 0.3s ease-out',
    }}>
      {/* Toggle handle */}
      <button
        onClick={() => setExpanded(!expanded)}
        style={{
          position: 'absolute',
          top: '-32px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: 'rgba(0, 0, 0, 0.9)',
          border: '1px solid rgba(255, 255, 255, 0.2)',
          borderBottom: 'none',
          borderTopLeftRadius: '8px',
          borderTopRightRadius: '8px',
          padding: '6px 20px',
          color: '#fff',
          fontSize: '12px',
          cursor: 'pointer',
          fontFamily: "'Helvetica Condensed', sans-serif",
        }}
      >
        {expanded ? 'Hide Simulator' : 'Show Simulator'}
      </button>

      {/* Multiplier selector */}
      <div style={{ display: 'flex', gap: '8px', marginBottom: '12px', justifyContent: 'center' }}>
        {(['single', 'double', 'triple'] as const).map((mode) => (
          <button
            key={mode}
            onClick={() => setMultiplierMode(mode)}
            disabled={disabled}
            style={{
              padding: '6px 16px',
              background: multiplierMode === mode ? (mode === 'triple' ? '#FF4444' : mode === 'double' ? '#44FF44' : '#6600FF') : 'rgba(255, 255, 255, 0.1)',
              color: '#fff',
              border: 'none',
              borderRadius: '6px',
              cursor: disabled ? 'not-allowed' : 'pointer',
              fontFamily: "'Helvetica Condensed', sans-serif",
              fontSize: '14px',
              fontWeight: 600,
              opacity: disabled ? 0.5 : 1,
              textTransform: 'uppercase',
            }}
          >
            {mode === 'single' ? 'Single (S)' : mode === 'double' ? 'Double (D)' : 'Triple (T)'}
          </button>
        ))}
      </div>

      {/* Number grid - dartboard order */}
      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', justifyContent: 'center', marginBottom: '12px' }}>
        {dartboardOrder.map((num) => (
          <button
            key={num}
            onClick={() => handleNumberClick(num)}
            disabled={disabled}
            style={{
              width: '44px',
              height: '36px',
              background: 'rgba(255, 255, 255, 0.1)',
              color: '#fff',
              border: '1px solid rgba(255, 255, 255, 0.2)',
              borderRadius: '4px',
              cursor: disabled ? 'not-allowed' : 'pointer',
              fontFamily: "'Helvetica Condensed', sans-serif",
              fontSize: '16px',
              fontWeight: 600,
              opacity: disabled ? 0.5 : 1,
            }}
          >
            {num}
          </button>
        ))}
      </div>

      {/* Bull and Miss buttons */}
      <div style={{ display: 'flex', gap: '8px', justifyContent: 'center' }}>
        <button
          onClick={() => handleBullClick(false)}
          disabled={disabled}
          style={{
            padding: '8px 20px',
            background: '#228B22',
            color: '#fff',
            border: 'none',
            borderRadius: '6px',
            cursor: disabled ? 'not-allowed' : 'pointer',
            fontFamily: "'Helvetica Condensed', sans-serif",
            fontSize: '14px',
            fontWeight: 600,
            opacity: disabled ? 0.5 : 1,
          }}
        >
          BULL (25)
        </button>
        <button
          onClick={() => handleBullClick(true)}
          disabled={disabled}
          style={{
            padding: '8px 20px',
            background: '#FF4444',
            color: '#fff',
            border: 'none',
            borderRadius: '6px',
            cursor: disabled ? 'not-allowed' : 'pointer',
            fontFamily: "'Helvetica Condensed', sans-serif",
            fontSize: '14px',
            fontWeight: 600,
            opacity: disabled ? 0.5 : 1,
          }}
        >
          D-BULL (50)
        </button>
        <button
          onClick={handleMissClick}
          disabled={disabled}
          style={{
            padding: '8px 20px',
            background: 'rgba(100, 100, 100, 0.5)',
            color: '#fff',
            border: 'none',
            borderRadius: '6px',
            cursor: disabled ? 'not-allowed' : 'pointer',
            fontFamily: "'Helvetica Condensed', sans-serif",
            fontSize: '14px',
            fontWeight: 600,
            opacity: disabled ? 0.5 : 1,
          }}
        >
          MISS
        </button>
      </div>
    </div>
  );
}

interface DartThrow {
  segment: string;
  score: number;
  multiplier: number;
}

// Snapshot of state before a single dart throw (for undo)
interface DartSnapshot {
  p1Score: number;
  p2Score: number;
  currentThrower: 'p1' | 'p2';
  currentDarts: DartThrow[];
  roundScore: number;
  p1HasStarted: boolean;
  p2HasStarted: boolean;
}

// Achievement types for animations
// - win: Player reaches exactly 0
// - bust: Player goes below 0 or can't finish legally
// - hatTrick: 3 bulls in one turn (any combo S25/D25)
// - threeInBlack: 3 double bulls (D25 D25 D25)
// - ton80: T20 T20 T20 (180)
// - threeInBed: 3 in same triple space (01), or 3 in cricket marks (cricket)
// - whiteHorse: Cricket only, 3 DIFFERENT triples
// - shanghai: 01 only, same number with S + D + T (e.g., S20 D20 T20)
// - highTon: 150+ in a round
// - lowTon: 100-149 in a round
type AchievementType =
  | 'win'
  | 'bust'
  | 'hatTrick'
  | 'threeInBlack'
  | 'ton80'
  | 'threeInBed'
  | 'whiteHorse'
  | 'shanghai'
  | 'highTon'
  | 'lowTon'
  | null;

// Figma exact colors
const P1_ACTIVE = '#6600FF';
const P2_ACTIVE = '#FB00FF';
const INACTIVE = '#7E7E7E';

// Figma fonts (loaded via @font-face in globals.css)
const FONT_SCORE = "'Helvetica Compressed', sans-serif";
const FONT_NAME = "'Helvetica Condensed', sans-serif";

// Figma frame: 1180 x 820
// Bar: 513 x 118, avatar 75px, name 40px, score 96px
const FIGMA = {
  frame: { w: 1180, h: 820 },
  bar: { w: 513, h: 118 },
  avatar: 75,
  avatarLeft: 12,
  nameLeft: 100,
  nameSize: 40,
  scoreLeft: 373,
  scoreSize: 96,
};

const PLAYERS = {
  p1: { id: 'p1', name: 'PLAYER1', profilecolor: '#6600FF' },
  p2: { id: 'p2', name: 'PLAYER2', profilecolor: '#FB00FF' },
};

const ROUND_WORDS = ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE', 'TEN',
  'ELEVEN', 'TWELVE', 'THIRTEEN', 'FOURTEEN', 'FIFTEEN', 'SIXTEEN', 'SEVENTEEN', 'EIGHTEEN', 'NINETEEN', 'TWENTY'];

// Game type abbreviations for match format display
const GAME_ABBREV: Record<string, string> = {
  '501': '01',
  '301': '01',
  'cricket': 'CR',
  'choice': 'CH', // Winner of cork picks the game type
};

// Achievement display names
const ACHIEVEMENT_LABELS: Record<Exclude<AchievementType, null>, string> = {
  win: 'GAME!',
  bust: 'BUST!',
  hatTrick: 'HAT TRICK!',
  threeInBlack: '3 IN THE BLACK!',
  ton80: 'TON 80!',
  threeInBed: '3 IN A BED!',
  whiteHorse: 'WHITE HORSE!',
  shanghai: 'SHANGHAI!',
  highTon: 'HIGH TON!',
  lowTon: 'LOW TON!',
};


// Checkout suggestions for 01 games (Double Out)
const CHECKOUTS: Record<number, string> = {
  170: 'T20 T20 Bull',
  167: 'T20 T19 Bull',
  164: 'T20 T18 Bull',
  161: 'T20 T17 Bull',
  160: 'T20 T20 D20',
  158: 'T20 T20 D19',
  157: 'T20 T19 D20',
  156: 'T20 T20 D18',
  155: 'T20 T19 D19',
  154: 'T20 T18 D20',
  153: 'T20 T19 D18',
  152: 'T20 T20 D16',
  151: 'T20 T17 D20',
  150: 'T20 T18 D18',
  149: 'T20 T19 D16',
  148: 'T20 T20 D14',
  147: 'T20 T17 D18',
  146: 'T20 T18 D16',
  145: 'T20 T19 D14',
  144: 'T20 T20 D12',
  143: 'T20 T17 D16',
  142: 'T20 T14 D20',
  141: 'T20 T19 D12',
  140: 'T20 T20 D10',
  139: 'T20 T13 D20',
  138: 'T20 T18 D12',
  137: 'T20 T19 D10',
  136: 'T20 T20 D8',
  135: 'T20 T17 D12',
  134: 'T20 T14 D16',
  133: 'T20 T19 D8',
  132: 'T20 T16 D12',
  131: 'T20 T13 D16',
  130: 'T20 T18 D8',
  129: 'T19 T16 D12',
  128: 'T18 T14 D16',
  127: 'T20 T17 D8',
  126: 'T19 T19 D6',
  125: 'T20 T19 D4',
  124: 'T20 T16 D8',
  123: 'T19 T16 D9',
  122: 'T18 T18 D7',
  121: 'T20 T11 D14',
  120: 'T20 S20 D20',
  119: 'T19 T12 D13',
  118: 'T20 S18 D20',
  117: 'T20 S17 D20',
  116: 'T20 S16 D20',
  115: 'T20 S15 D20',
  114: 'T20 S14 D20',
  113: 'T20 S13 D20',
  112: 'T20 T12 D8',
  111: 'T20 S11 D20',
  110: 'T20 S10 D20',
  109: 'T20 S9 D20',
  108: 'T20 S16 D16',
  107: 'T19 S10 D20',
  106: 'T20 S6 D20',
  105: 'T20 S5 D20',
  104: 'T20 S4 D20',
  103: 'T19 S6 D20',
  102: 'T20 S2 D20',
  101: 'T17 S10 D20',
  100: 'T20 D20',
  99: 'T19 S10 D16',
  98: 'T20 D19',
  97: 'T19 D20',
  96: 'T20 D18',
  95: 'T19 D19',
  94: 'T18 D20',
  93: 'T19 D18',
  92: 'T20 D16',
  91: 'T17 D20',
  90: 'T18 D18',
  89: 'T19 D16',
  88: 'T20 D14',
  87: 'T17 D18',
  86: 'T18 D16',
  85: 'T19 D14',
  84: 'T20 D12',
  83: 'T17 D16',
  82: 'T14 D20',
  81: 'T19 D12',
  80: 'T20 D10',
  79: 'T13 D20',
  78: 'T18 D12',
  77: 'T19 D10',
  76: 'T20 D8',
  75: 'T17 D12',
  74: 'T14 D16',
  73: 'T19 D8',
  72: 'T16 D12',
  71: 'T13 D16',
  70: 'T18 D8',
  69: 'T19 D6',
  68: 'T20 D4',
  67: 'T17 D8',
  66: 'T10 D18',
  65: 'T19 D4',
  64: 'T16 D8',
  63: 'T13 D12',
  62: 'T10 D16',
  61: 'T15 D8',
  60: 'S20 D20',
  59: 'S19 D20',
  58: 'S18 D20',
  57: 'S17 D20',
  56: 'T16 D4',
  55: 'S15 D20',
  54: 'S14 D20',
  53: 'S13 D20',
  52: 'T12 D8',
  51: 'S11 D20',
  50: 'S10 D20',
  49: 'S9 D20',
  48: 'S16 D16',
  47: 'S7 D20',
  46: 'S6 D20',
  45: 'S13 D16',
  44: 'S4 D20',
  43: 'S3 D20',
  42: 'S10 D16',
  41: 'S9 D16',
  40: 'D20',
  39: 'S7 D16',
  38: 'D19',
  37: 'S5 D16',
  36: 'D18',
  35: 'S3 D16',
  34: 'D17',
  33: 'S1 D16',
  32: 'D16',
  31: 'S15 D8',
  30: 'D15',
  29: 'S13 D8',
  28: 'D14',
  27: 'S11 D8',
  26: 'D13',
  25: 'S9 D8',
  24: 'D12',
  23: 'S7 D8',
  22: 'D11',
  21: 'S5 D8',
  20: 'D10',
  19: 'S3 D8',
  18: 'D9',
  17: 'S1 D8',
  16: 'D8',
  15: 'S7 D4',
  14: 'D7',
  13: 'S5 D4',
  12: 'D6',
  11: 'S3 D4',
  10: 'D5',
  9: 'S1 D4',
  8: 'D4',
  7: 'S3 D2',
  6: 'D3',
  5: 'S1 D2',
  4: 'D2',
  3: 'S1 D1',
  2: 'D1',
};

// CSS keyframes for the GOOD LUCK animation and color reveal
const goodLuckKeyframes = `
@keyframes goodLuckSlide {
  0% {
    left: 100%;
    transform: translate(0, -50%);
  }
  25% {
    left: 50%;
    transform: translate(-50%, -50%);
  }
  75% {
    left: 50%;
    transform: translate(-50%, -50%);
  }
  100% {
    left: -100%;
    transform: translate(0, -50%);
  }
}

@keyframes goodLuckBgSlide {
  0% {
    left: 100%;
    width: 40%;
    transform: translateY(-50%);
  }
  25% {
    left: 0;
    width: 100%;
    transform: translateY(-50%);
  }
  75% {
    left: 0;
    width: 100%;
    transform: translateY(-50%);
  }
  100% {
    left: -100%;
    width: 40%;
    transform: translateY(-50%);
  }
}

@keyframes colorSwipeUp {
  0% {
    clip-path: inset(100% 0 0 0);
  }
  100% {
    clip-path: inset(0 0 0 0);
  }
}

@keyframes colorSwipeDown {
  0% {
    clip-path: inset(0 0 0 0);
  }
  100% {
    clip-path: inset(100% 0 0 0);
  }
}

@keyframes borderDrainDown {
  0% {
    transform: translateY(0);
    opacity: 1;
  }
  100% {
    transform: translateY(calc(118 * 100vw / 1180));
    opacity: 0;
  }
}

@keyframes slideInFromLeft {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(0);
  }
}

@keyframes slideOutToLeft {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-100%);
  }
}

@keyframes achievementPulse {
  0% {
    transform: translate(-50%, -50%) scale(0.5);
    opacity: 0;
  }
  20% {
    transform: translate(-50%, -50%) scale(1.2);
    opacity: 1;
  }
  40% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  80% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0;
  }
}

@keyframes achievementGlow {
  0%, 100% {
    filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 0 40px currentColor);
  }
  50% {
    filter: drop-shadow(0 0 40px currentColor) drop-shadow(0 0 80px currentColor);
  }
}

@keyframes winnerFadeIn {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

@keyframes winnerNameSlide {
  0% {
    transform: translateY(50px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes winnerConfetti {
  0% {
    transform: translateY(-10px) rotate(0deg);
  }
  50% {
    transform: translateY(10px) rotate(180deg);
  }
  100% {
    transform: translateY(-10px) rotate(360deg);
  }
}
`;

interface O1GSPreviewProps {
  onLeaveMatch?: () => void;
}

export function O1GSPreview({ onLeaveMatch }: O1GSPreviewProps) {
  const [p1Score, setP1Score] = useState(301);
  const [p2Score, setP2Score] = useState(301);
  const [currentThrower, setCurrentThrower] = useState<'p1' | 'p2'>('p1');
  const [currentDarts, setCurrentDarts] = useState<DartThrow[]>([]);
  const [roundScore, setRoundScore] = useState(0);
  const [showPlayerChange, setShowPlayerChange] = useState(false);
  const [introComplete, setIntroComplete] = useState(false);
  const [showGoodLuck, setShowGoodLuck] = useState(true);
  const [menuOpen, setMenuOpen] = useState(false);
  const [currentRound, setCurrentRound] = useState(1);
  const [roundAnimState, setRoundAnimState] = useState<'in' | 'visible' | 'out'>('in');
  const [roundKey, setRoundKey] = useState(0);
  const [p1ThrewThisRound, setP1ThrewThisRound] = useState(false);
  const [p2ThrewThisRound, setP2ThrewThisRound] = useState(false);
  const [dartHistory, setDartHistory] = useState<DartSnapshot[]>([]);
  const [undosRemaining, setUndosRemaining] = useState(3);
  const [activeAnimation, setActiveAnimation] = useState<AchievementType>(null);
  const [gameWinner, setGameWinner] = useState<'p1' | 'p2' | null>(null);
  const [showWinnerScreen, setShowWinnerScreen] = useState(false);

  // Medley match tracking
  const [matchGameWinners, setMatchGameWinners] = useState<('p1' | 'p2')[]>([]); // Winners of each game in match
  const [currentGameIndex, setCurrentGameIndex] = useState(0); // Which game we're on (0-indexed)

  // 80% Stat Tracking
  // For 01: PPR = (startScore - currentScore) / dartsThrown
  // For Cricket: MPR = totalMarks / rounds
  const [p1DartsThrown, setP1DartsThrown] = useState(0);
  const [p2DartsThrown, setP2DartsThrown] = useState(0);
  const [eightyPercentTriggered, setEightyPercentTriggered] = useState(false); // Has 80% been reached?
  const [p1FrozenPPR, setP1FrozenPPR] = useState<number | null>(null); // Frozen PPR at 80%
  const [p2FrozenPPR, setP2FrozenPPR] = useState<number | null>(null);

  // Track if each player has "started" (hit their first valid in for DI/MIMO modes)
  const [p1HasStarted, setP1HasStarted] = useState(false);
  const [p2HasStarted, setP2HasStarted] = useState(false);

  // Match format: array of game types
  // Example: ['501', 'cricket', 'choice'] for a best-of-3
  const [matchGames] = useState<string[]>(['501', 'cricket', 'choice']); // Demo: best-of-3

  // Game settings: Separate IN and OUT modes (any combo allowed)
  // Open = any dart, Master = double/triple/any bull, Double = outer double or D25 only
  const [inMode] = useState<'open' | 'master' | 'double'>('open'); // Demo: Open In
  const [outMode] = useState<'open' | 'master' | 'double'>('master'); // Demo: Master Out
  const [splitBull] = useState(false); // Demo: Full Bull (50/50)

  const currentScore = currentThrower === 'p1' ? p1Score : p2Score;

  // Get current game type from match
  const currentGameType = matchGames[currentGameIndex] || '501';
  const isOhOneGame = ['501', '301'].includes(currentGameType);
  const isCricketGame = currentGameType === 'cricket';
  const isChoiceGame = currentGameType === 'choice';

  // Starting score for 01 games (used for PPR calculation)
  const startScore = currentGameType === '501' ? 501 : 301;

  // 80% threshold: points remaining when stats should freeze
  // 301: <=50 remaining (scored >=251)
  // 501: <=100 remaining (scored >=401)
  const eightyPercentThreshold = currentGameType === '501' ? 100 : 50;

  // Calculate live PPR for each player (Points Per Round = points scored / darts thrown * 3)
  // PPR = (startScore - currentScore) / dartsThrown * 3
  const p1LivePPR = p1DartsThrown > 0 ? ((startScore - p1Score) / p1DartsThrown) * 3 : 0;
  const p2LivePPR = p2DartsThrown > 0 ? ((startScore - p2Score) / p2DartsThrown) * 3 : 0;

  // Display PPR: use frozen value if 80% triggered, otherwise live
  const p1DisplayPPR = eightyPercentTriggered && p1FrozenPPR !== null ? p1FrozenPPR : p1LivePPR;
  const p2DisplayPPR = eightyPercentTriggered && p2FrozenPPR !== null ? p2FrozenPPR : p2LivePPR;

  // Medley match logic
  const isMedley = matchGames.length > 1;
  const p1MatchWins = matchGameWinners.filter(w => w === 'p1').length;
  const p2MatchWins = matchGameWinners.filter(w => w === 'p2').length;
  const gamesNeededToWin = Math.ceil(matchGames.length / 2);
  const matchWinner = p1MatchWins >= gamesNeededToWin ? 'p1' : p2MatchWins >= gamesNeededToWin ? 'p2' : null;
  const isTiebreakerGame = currentGameIndex === matchGames.length - 1 && p1MatchWins === p2MatchWins && p1MatchWins > 0;

  // Determine who should throw first for next game
  // - First game: Cork
  // - Middle games: Loser of previous game goes first
  // - Last game (tiebreaker): Cork
  const getNextGameStarter = (): 'p1' | 'p2' | 'cork' => {
    const nextGameIndex = currentGameIndex + 1;

    // First game - cork to start
    if (nextGameIndex === 0) {
      return 'cork';
    }

    // Last game (tiebreaker) - cork again
    if (nextGameIndex === matchGames.length - 1) {
      // Only cork if it's actually a tiebreaker (scores are tied going in)
      const p1WinsAfterThis = p1MatchWins + (gameWinner === 'p1' ? 1 : 0);
      const p2WinsAfterThis = p2MatchWins + (gameWinner === 'p2' ? 1 : 0);
      if (p1WinsAfterThis === p2WinsAfterThis) {
        return 'cork';
      }
    }

    // Middle games - loser of previous game goes first
    if (gameWinner) return gameWinner === 'p1' ? 'p2' : 'p1';

    // Fallback to loser of last recorded game
    const lastWinner = matchGameWinners[matchGameWinners.length - 1];
    if (lastWinner) return lastWinner === 'p1' ? 'p2' : 'p1';

    return 'cork'; // fallback to cork if unsure
  };

  // Start the next game in medley
  const startNextGame = useCallback((firstThrower: 'p1' | 'p2') => {
    // Record current game winner
    if (gameWinner) {
      setMatchGameWinners(prev => [...prev, gameWinner]);
    }

    // Reset game state
    setShowWinnerScreen(false);
    setGameWinner(null);
    setP1Score(301);
    setP2Score(301);
    setCurrentDarts([]);
    setRoundScore(0);
    setCurrentRound(1);
    setP1ThrewThisRound(false);
    setP2ThrewThisRound(false);
    setP1HasStarted(false);
    setP2HasStarted(false);
    setDartHistory([]);
    setUndosRemaining(3);
    setCurrentThrower(firstThrower);
    setCurrentGameIndex(prev => prev + 1);
    setShowGoodLuck(true);
    setIntroComplete(false);

    // Reset 80% stat tracking for new game
    setP1DartsThrown(0);
    setP2DartsThrown(0);
    setEightyPercentTriggered(false);
    setP1FrozenPPR(null);
    setP2FrozenPPR(null);
  }, [gameWinner]);

  // Detect achievements based on the 3 darts thrown
  // Priority: win > ton80 > threeInBlack > shanghai > whiteHorse > hatTrick > threeInBed > highTon > lowTon > bust
  const detectAchievement = useCallback((darts: DartThrow[], totalScore: number, didBust: boolean, didWin: boolean): AchievementType => {
    if (darts.length !== 3) return didBust ? 'bust' : didWin ? 'win' : null;

    // Win takes precedence
    if (didWin) return 'win';

    // Extract dart info
    const segments = darts.map(d => d.segment);

    // Ton 80: T20 T20 T20 (exactly 180)
    if (segments.every(s => s === 'T20')) return 'ton80';

    // 3 in the Black: D25 D25 D25 (3 double bulls)
    if (segments.every(s => s === 'D25')) return 'threeInBlack';

    // Shanghai (01 only): Same number with S + D + T (e.g., S20 D20 T20)
    if (isOhOneGame) {
      // Extract base numbers from segments
      const getBaseNumber = (seg: string): number | null => {
        if (seg === 'S25' || seg === 'D25' || seg === 'MISS') return null;
        const match = seg.match(/[SDT](\d+)/);
        return match ? parseInt(match[1], 10) : null;
      };
      const baseNumbers = segments.map(getBaseNumber);
      // All same number and we have S, D, T of it
      if (baseNumbers.every(n => n !== null && n === baseNumbers[0])) {
        const prefixes = segments.map(s => s[0]);
        if (prefixes.includes('S') && prefixes.includes('D') && prefixes.includes('T')) {
          return 'shanghai';
        }
      }
    }

    // White Horse (Cricket only): 3 DIFFERENT triples
    if (isCricketGame) {
      const triples = segments.filter(s => s.startsWith('T'));
      if (triples.length === 3) {
        const uniqueTriples = new Set(triples);
        if (uniqueTriples.size === 3) return 'whiteHorse';
      }
    }

    // Hat Trick: 3 bulls (any combo of S25/D25)
    const bullCount = segments.filter(s => s === 'S25' || s === 'D25').length;
    if (bullCount === 3) return 'hatTrick';

    // 3 in a Bed: 3 in same triple space
    // For 01: any triple
    // For Cricket: must be cricket numbers (20, 19, 18, 17, 16, 15)
    const triples = segments.filter(s => s.startsWith('T'));
    if (triples.length === 3 && triples[0] === triples[1] && triples[1] === triples[2]) {
      if (isOhOneGame) {
        return 'threeInBed';
      } else if (isCricketGame) {
        const cricketNumbers = ['T20', 'T19', 'T18', 'T17', 'T16', 'T15'];
        if (cricketNumbers.includes(triples[0])) {
          return 'threeInBed';
        }
      }
    }

    // High Ton: 150+ in a round
    if (totalScore >= 150) return 'highTon';

    // Low Ton: 100-149 in a round
    if (totalScore >= 100) return 'lowTon';

    // Bust (if nothing else)
    if (didBust) return 'bust';

    return null;
  }, [isOhOneGame, isCricketGame]);

  // Trigger achievement animation
  const triggerAchievement = useCallback((achievement: AchievementType, winner?: 'p1' | 'p2') => {
    if (!achievement) return;
    setActiveAnimation(achievement);
    // Clear animation after it completes
    setTimeout(() => {
      setActiveAnimation(null);
      // If it was a win, show the winners screen after animation
      if (achievement === 'win' && winner) {
        setGameWinner(winner);
        // Small delay before showing winners screen for dramatic effect
        setTimeout(() => setShowWinnerScreen(true), 300);
      }
    }, 2000);
  }, []);

  // Undo last dart (max 3 per game)
  const handleUndo = useCallback(() => {
    if (dartHistory.length === 0 || undosRemaining <= 0) return;

    const prevState = dartHistory[dartHistory.length - 1];
    setP1Score(prevState.p1Score);
    setP2Score(prevState.p2Score);
    setCurrentThrower(prevState.currentThrower);
    setCurrentDarts(prevState.currentDarts);
    setRoundScore(prevState.roundScore);
    setP1HasStarted(prevState.p1HasStarted);
    setP2HasStarted(prevState.p2HasStarted);
    setDartHistory(prev => prev.slice(0, -1));
    setUndosRemaining(prev => prev - 1);
  }, [dartHistory, undosRemaining]);

  // Intro animation timer
  useEffect(() => {
    const timer = setTimeout(() => {
      setShowGoodLuck(false);
      setIntroComplete(true);
    }, 4000); // Animation duration
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    if (showPlayerChange) {
      const timer = setTimeout(() => {
        // Track who threw this round
        if (currentThrower === 'p1') {
          setP1ThrewThisRound(true);
        } else {
          setP2ThrewThisRound(true);
        }

        // 80% Stat Check: At end of player's turn, check if they crossed threshold
        // If ANY player reaches 80%, freeze BOTH players' stats immediately
        if (isOhOneGame && !eightyPercentTriggered) {
          const playerScore = currentThrower === 'p1' ? p1Score : p2Score;
          if (playerScore <= eightyPercentThreshold) {
            // First player to reach 80% - freeze both stats
            setEightyPercentTriggered(true);
            // Calculate and freeze PPR for both players at this moment
            const p1PPR = p1DartsThrown > 0 ? ((startScore - p1Score) / p1DartsThrown) * 3 : 0;
            const p2PPR = p2DartsThrown > 0 ? ((startScore - p2Score) / p2DartsThrown) * 3 : 0;
            setP1FrozenPPR(p1PPR);
            setP2FrozenPPR(p2PPR);
          }
        }

        // Check if round is complete (both players threw)
        const willCompleteRound = (currentThrower === 'p1' && p2ThrewThisRound) ||
                                   (currentThrower === 'p2' && p1ThrewThisRound);

        if (willCompleteRound) {
          // Start round exit animation
          setRoundAnimState('out');
          setTimeout(() => {
            setCurrentRound(prev => prev + 1);
            setRoundKey(prev => prev + 1);
            setP1ThrewThisRound(false);
            setP2ThrewThisRound(false);
            setRoundAnimState('in');
          }, 500); // Wait for exit animation
        }

        setShowPlayerChange(false);
        setCurrentThrower(currentThrower === 'p1' ? 'p2' : 'p1');
        setCurrentDarts([]);
        setRoundScore(0);
      }, 1500);
      return () => clearTimeout(timer);
    }
  }, [showPlayerChange, currentThrower, p1ThrewThisRound, p2ThrewThisRound, isOhOneGame, eightyPercentTriggered, p1Score, p2Score, eightyPercentThreshold, p1DartsThrown, p2DartsThrown, startScore]);

  const throwDart = useCallback((segment: string, score: number, multiplier: number) => {
    if (currentDarts.length >= 3 || showPlayerChange || !introComplete) return;

    const hasStarted = currentThrower === 'p1' ? p1HasStarted : p2HasStarted;
    const setHasStarted = currentThrower === 'p1' ? setP1HasStarted : setP2HasStarted;

    // Save snapshot BEFORE this dart (for undo)
    const snapshot: DartSnapshot = {
      p1Score,
      p2Score,
      currentThrower,
      currentDarts: [...currentDarts],
      roundScore,
      p1HasStarted,
      p2HasStarted,
    };
    setDartHistory(prev => [...prev, snapshot]);

    // Check dart types
    const isDouble = multiplier === 2; // Outer ring doubles AND D25 (double bull)
    const isTriple = multiplier === 3;
    const isSingleBull = segment === 'S25';
    const isDoubleBull = segment === 'D25';
    const isAnyBull = isSingleBull || isDoubleBull;

    // Valid IN check based on inMode:
    // - open: any dart
    // - master: double, triple, or any bull (S25/D25)
    // - double: outer ring double OR double bull (D25) only - NOT single bull
    const isValidIn = inMode === 'open' ||
                      (inMode === 'master' && (isDouble || isTriple || isAnyBull)) ||
                      (inMode === 'double' && isDouble); // D25 is multiplier 2, so isDouble covers it

    // If player hasn't started and this isn't a valid in, dart counts but scores 0
    let effectiveScore = score;
    let playerStartsNow = false;

    if (!hasStarted) {
      if (isValidIn && score > 0) {
        // Player starts with this dart
        playerStartsNow = true;
        effectiveScore = score;
      } else {
        // Dart thrown but doesn't count toward score
        effectiveScore = 0;
      }
    }

    // Valid OUT check based on outMode:
    // - open: any dart that makes score exactly 0
    // - master: double, triple, or any bull AND makes score exactly 0
    // - double: outer ring double OR double bull (D25) AND makes score exactly 0
    const potentialNewScore = currentScore - effectiveScore;
    const isValidOut = outMode === 'open' ||
                       (outMode === 'master' && (isDouble || isTriple || isAnyBull)) ||
                       (outMode === 'double' && isDouble); // D25 is multiplier 2

    // Bust conditions:
    // 1. Score goes below 0
    // 2. Score lands on exactly 1 (can't finish with 1 remaining)
    // 3. Score lands on 0 but the dart wasn't a valid out
    const isBust = potentialNewScore < 0 ||
                   potentialNewScore === 1 ||
                   (potentialNewScore === 0 && !isValidOut);

    const newDart: DartThrow = { segment, score: effectiveScore, multiplier };
    const newDarts = [...currentDarts, newDart];
    const newRoundScore = roundScore + effectiveScore;

    // Track darts thrown for PPR calculation
    if (currentThrower === 'p1') {
      setP1DartsThrown(prev => prev + 1);
    } else {
      setP2DartsThrown(prev => prev + 1);
    }

    if (isBust) {
      // Show the dart but don't update score, then switch players
      setCurrentDarts(newDarts);
      // Trigger bust achievement
      const achievement = detectAchievement(newDarts, newRoundScore, true, false);
      triggerAchievement(achievement);
      setTimeout(() => setShowPlayerChange(true), 2000); // Wait for animation
      return;
    }

    // Check for win (score reaches exactly 0)
    const didWin = potentialNewScore === 0;

    // Update state
    setCurrentDarts(newDarts);
    setRoundScore(newRoundScore);
    if (currentThrower === 'p1') setP1Score(potentialNewScore);
    else setP2Score(potentialNewScore);

    // Mark player as started if they just hit a valid in
    if (playerStartsNow) {
      setHasStarted(true);
    }

    // Check for achievements on 3rd dart or win
    if (newDarts.length === 3 || didWin) {
      const achievement = detectAchievement(newDarts, newRoundScore, false, didWin);
      if (achievement) {
        // Pass winner for win achievements (single game = show winner screen after)
        const winner = didWin ? currentThrower : undefined;
        triggerAchievement(achievement, winner);
        // Don't show player change on win - winners screen will show
        if (!didWin) {
          setTimeout(() => setShowPlayerChange(true), 2000); // Wait for animation
        }
        return;
      }
    }

    if (newDarts.length === 3) setShowPlayerChange(true);
  }, [currentDarts, currentScore, currentThrower, roundScore, showPlayerChange, introComplete, p1Score, p2Score, p1HasStarted, p2HasStarted, inMode, outMode, detectAchievement, triggerAchievement]);

  const formatDart = (segment: string) => {
    if (segment === 'MISS') return 'MISS';
    if (segment === 'S25') return 'BULL';
    if (segment === 'D25') return 'DBULL';
    return segment;
  };

  const p1Active = currentThrower === 'p1';
  const p2Active = currentThrower === 'p2';

  // Grey gradient for inactive/intro state
  const greyGradient = 'linear-gradient(179.4deg, rgba(126, 126, 126, 0.2) 0.52%, rgba(0, 0, 0, 0.2) 95.46%)';

  // Track previous thrower for exit animations
  const [prevThrower, setPrevThrower] = useState<'p1' | 'p2' | null>(null);
  const [turnKey, setTurnKey] = useState(0);
  const [hasHadTurnSwitch, setHasHadTurnSwitch] = useState(false);

  // Track turn changes - only set prevThrower after actual turn switch (not on initial intro)
  useEffect(() => {
    if (introComplete) {
      // Only track as exit if there was a previous turn (not initial intro)
      if (turnKey > 0) {
        setPrevThrower(currentThrower === 'p1' ? 'p2' : 'p1');
        setHasHadTurnSwitch(true);
      }
      setTurnKey(prev => prev + 1);
    }
  }, [currentThrower, introComplete]);

  // Determine if each player is exiting (was active, now inactive) - only after first turn switch
  const p1Exiting = hasHadTurnSwitch && prevThrower === 'p1' && !p1Active;
  const p2Exiting = hasHadTurnSwitch && prevThrower === 'p2' && !p2Active;

  // Scale factor based on viewport vs Figma frame
  // Use vw for width-based scaling
  const scale = `calc(100vw / ${FIGMA.frame.w})`;

  return (
    <div style={{
      position: 'relative',
      width: '100vw',
      height: '100vh',
      background: '#000000',
      overflow: 'hidden',
    }}>
      {/* Inject keyframes */}
      <style>{goodLuckKeyframes}</style>

      {/* Background */}
      <div style={{
        position: 'absolute',
        inset: 0,
        backgroundImage: 'url(/assets/gamescreenbackground.png)',
        backgroundSize: 'cover',
        backgroundPosition: 'center',
      }} />

      {/* Match Format / Checkout Display - Top Center */}
      {matchGames.length > 0 && (
        <div style={{
          position: 'absolute',
          top: `calc(20 * ${scale})`,
          left: '50%',
          transform: 'translateX(-50%)',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: `calc(4 * ${scale})`,
          padding: `calc(8 * ${scale}) calc(16 * ${scale})`,
          background: 'rgba(0, 0, 0, 0.5)',
          backdropFilter: 'blur(12px)',
          WebkitBackdropFilter: 'blur(12px)',
          borderRadius: `calc(8 * ${scale})`,
          border: '1px solid rgba(255, 255, 255, 0.1)',
          zIndex: 50,
        }}>
          {/* Show checkout when score < 150, otherwise show match format */}
          {currentScore <= 170 && currentScore >= 2 && CHECKOUTS[currentScore] ? (
            <>
              {/* Checkout suggestion */}
              <div style={{
                fontFamily: FONT_NAME,
                fontWeight: 700,
                fontSize: `calc(28 * ${scale})`,
                color: '#FFFFFF',
                textShadow: '-2px 2px 4px rgba(0, 0, 0, 0.5)',
              }}>
                {CHECKOUTS[currentScore]}
              </div>
              <div style={{
                fontFamily: FONT_NAME,
                fontSize: `calc(12 * ${scale})`,
                color: 'rgba(255, 255, 255, 0.5)',
              }}>
                Checkout
              </div>
            </>
          ) : (
            <>
              {/* Game types row */}
              <div style={{ display: 'flex', alignItems: 'center', gap: `calc(8 * ${scale})` }}>
                {matchGames.map((game, index) => (
                  <span key={index} style={{ display: 'flex', alignItems: 'center' }}>
                    {index > 0 && (
                      <span style={{
                        color: 'rgba(255, 255, 255, 0.3)',
                        fontFamily: FONT_NAME,
                        fontSize: `calc(24 * ${scale})`,
                        marginRight: `calc(8 * ${scale})`,
                      }}>|</span>
                    )}
                    <span style={{
                      fontFamily: FONT_NAME,
                      fontWeight: index === currentGameIndex ? 700 : 400,
                      fontSize: `calc(24 * ${scale})`,
                      color: index === currentGameIndex ? '#FFFFFF' : 'rgba(255, 255, 255, 0.4)',
                      textShadow: index === currentGameIndex ? '-2px 2px 4px rgba(0, 0, 0, 0.5)' : 'none',
                    }}>
                      {GAME_ABBREV[game] || game.toUpperCase()}
                    </span>
                  </span>
                ))}
              </div>
              {/* Settings row - abbreviated format, hide opens and fat bull */}
              {/* Combine in/out modes: MiMo, DiDo, MiDo, DiMo, or single Mi/Mo/Di/Do */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: `calc(8 * ${scale})`,
                fontFamily: FONT_NAME,
                fontSize: `calc(14 * ${scale})`,
                color: 'rgba(255, 255, 255, 0.5)',
              }}>
                {/* Combined in/out display */}
                {inMode !== 'open' && outMode !== 'open' && (
                  <span>
                    {inMode === 'master' ? 'Mi' : 'Di'}
                    {outMode === 'master' ? 'Mo' : 'Do'}
                  </span>
                )}
                {/* Single in (out is open) */}
                {inMode !== 'open' && outMode === 'open' && (
                  <span>{inMode === 'master' ? 'Mi' : 'Di'}</span>
                )}
                {/* Single out (in is open) */}
                {inMode === 'open' && outMode !== 'open' && (
                  <span>{outMode === 'master' ? 'Mo' : 'Do'}</span>
                )}
                {splitBull && <span>SB</span>}
              </div>
            </>
          )}
        </div>
      )}

      {/* Center score */}
      <div style={{
        position: 'absolute',
        left: '50%',
        top: '40%',
        transform: 'translate(-50%, -50%)',
        fontFamily: FONT_SCORE,
        fontWeight: 300,
        fontSize: `calc(320 * ${scale})`,
        lineHeight: 1,
        color: '#FFFFFF',
        textShadow: '-6px 6px 9.7px rgba(0, 0, 0, 0.78)',
        zIndex: 10,
      }}>
        {currentThrower === 'p1' ? p1Score : p2Score}
      </div>

      {/* GOOD LUCK! Animation */}
      {showGoodLuck && (
        <>
          {/* Glassmorphic background bar */}
          <div style={{
            position: 'absolute',
            left: '100%',
            top: '50%',
            transform: 'translateY(-50%)',
            height: `calc(260 * ${scale})`,
            width: '40%',
            background: 'rgba(0, 0, 0, 0.5)',
            backdropFilter: 'blur(12px)',
            WebkitBackdropFilter: 'blur(12px)',
            borderTop: '1px solid rgba(255, 255, 255, 0.1)',
            borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
            zIndex: 99,
            animation: 'goodLuckBgSlide 4s ease-in-out forwards',
          }} />
          {/* Text */}
          <div style={{
            position: 'absolute',
            left: '100%',
            top: '50%',
            transform: 'translate(0, -50%)',
            fontFamily: FONT_SCORE,
            fontWeight: 300,
            fontSize: `calc(200 * ${scale})`,
            lineHeight: 1,
            color: '#FFFFFF',
            textShadow: '-6px 6px 9.7px rgba(0, 0, 0, 0.78)',
            whiteSpace: 'nowrap',
            zIndex: 100,
            animation: 'goodLuckSlide 4s ease-in-out forwards',
          }}>
            GOOD LUCK!
          </div>
        </>
      )}

      {/* Round Indicator - Upper Left */}
      {introComplete && (
        <div
          key={`round-${roundKey}`}
          style={{
            position: 'absolute',
            top: `calc(20 * ${scale})`,
            left: 0,
            display: 'flex',
            alignItems: 'center',
            zIndex: 50,
            animation: roundAnimState === 'out'
              ? 'slideOutToLeft 0.5s ease-in forwards'
              : roundAnimState === 'in'
                ? 'slideInFromLeft 0.5s ease-out forwards'
                : 'none',
          }}
        >
          {/* Glassmorphic background */}
          <div style={{
            padding: `calc(12 * ${scale}) calc(24 * ${scale})`,
            background: 'rgba(0, 0, 0, 0.5)',
            backdropFilter: 'blur(12px)',
            WebkitBackdropFilter: 'blur(12px)',
            borderTop: '1px solid rgba(255, 255, 255, 0.1)',
            borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
            borderRight: '1px solid rgba(255, 255, 255, 0.1)',
            borderRadius: `0 calc(8 * ${scale}) calc(8 * ${scale}) 0`,
          }}>
            <span style={{
              fontFamily: FONT_SCORE,
              fontWeight: 300,
              fontSize: `calc(48 * ${scale})`,
              lineHeight: 1,
              color: '#FFFFFF',
              textShadow: '-3px 3px 5px rgba(0, 0, 0, 0.78)',
              whiteSpace: 'nowrap',
            }}>
              ROUND {ROUND_WORDS[currentRound - 1] || currentRound}
            </span>
          </div>
        </div>
      )}

      {/* Darts above active player - each centered over its 1/3 of the bar */}
      {currentDarts.length > 0 && introComplete && (
        <>
          {currentDarts.map((dart, i) => {
            // Bar width is 513px, divide into thirds
            // Centers at: 85.5 (1/6), 256.5 (3/6), 427.5 (5/6)
            const thirdCenters = [85.5, 256.5, 427.5];
            const centerPos = thirdCenters[i];

            return (
              <div
                key={i}
                style={{
                  position: 'absolute',
                  bottom: `calc(${FIGMA.bar.h - 4} * ${scale})`,
                  ...(p1Active
                    ? { left: `calc(${centerPos} * ${scale})`, transform: 'translateX(-50%)' }
                    : { right: `calc(${centerPos} * ${scale})`, transform: 'translateX(50%)' }
                  ),
                  textAlign: 'center',
                }}
              >
                <div style={{
                  fontFamily: FONT_NAME,
                  fontWeight: 500,
                  fontSize: `calc(28 * ${scale})`,
                  color: '#FFFFFF',
                }}>
                  {formatDart(dart.segment)}
                </div>
              </div>
            );
          })}
        </>
      )}

      {/* Player 1 Bar - Left */}
      <div style={{
        position: 'absolute',
        width: `calc(${FIGMA.bar.w} * ${scale})`,
        height: `calc(${FIGMA.bar.h} * ${scale})`,
        left: '0px',
        bottom: '0px',
        borderTopRightRadius: `calc(16 * ${scale})`,
        overflow: 'hidden',
      }}>
        {/* Grey base layer - always visible */}
        <div style={{
          position: 'absolute',
          inset: 0,
          background: greyGradient,
        }} />
        {/* Dart progress border - top edge, 1/3 per dart when active, swipes down on exit */}
        {introComplete && p1Active && (
          <div style={{
            position: 'absolute',
            top: 0,
            left: 0,
            height: '3px',
            width: `${(currentDarts.length / 3) * 100}%`,
            background: P1_ACTIVE,
            transition: 'width 0.2s ease-out',
            zIndex: 5,
          }} />
        )}
        {introComplete && p1Exiting && (
          <div key={`p1-progress-exit-${turnKey}`} style={{
            position: 'absolute',
            top: 0,
            left: 0,
            height: '3px',
            width: '100%',
            background: P1_ACTIVE,
            zIndex: 5,
            animation: 'borderDrainDown 0.5s ease-out forwards',
          }} />
        )}
        {/* Colored layer - swipes up when active, swipes down when exiting */}
        {introComplete && (p1Active || p1Exiting) && (
          <div key={`p1-bar-${turnKey}`} style={{
            position: 'absolute',
            inset: 0,
            background: 'linear-gradient(179.4deg, rgba(102, 0, 255, 0.2) 0.52%, rgba(0, 0, 0, 0.2) 95.46%)',
            animation: p1Active ? 'colorSwipeUp 0.5s ease-out forwards' : 'colorSwipeDown 0.5s ease-out forwards',
          }} />
        )}
        {/* Avatar - grey base */}
        <div style={{
          position: 'absolute',
          width: `calc(${FIGMA.avatar} * ${scale})`,
          height: `calc(${FIGMA.avatar} * ${scale})`,
          left: `calc(${FIGMA.avatarLeft} * ${scale})`,
          top: '50%',
          transform: 'translateY(-50%)',
          background: '#000000',
          border: `3px solid ${INACTIVE}`,
          borderRadius: '50%',
          zIndex: 1,
        }} />
        {/* Avatar - colored overlay */}
        {introComplete && (p1Active || p1Exiting) && (
          <div key={`p1-avatar-${turnKey}`} style={{
            position: 'absolute',
            width: `calc(${FIGMA.avatar} * ${scale})`,
            height: `calc(${FIGMA.avatar} * ${scale})`,
            left: `calc(${FIGMA.avatarLeft} * ${scale})`,
            top: '50%',
            transform: 'translateY(-50%)',
            background: '#000000',
            border: `3px solid ${P1_ACTIVE}`,
            borderRadius: '50%',
            zIndex: 2,
            animation: p1Active ? 'colorSwipeUp 0.5s ease-out forwards' : 'colorSwipeDown 0.5s ease-out forwards',
          }} />
        )}
        {/* Name + PPR */}
        <div style={{
          position: 'absolute',
          left: `calc(${FIGMA.nameLeft} * ${scale})`,
          top: '50%',
          transform: 'translateY(-50%)',
          display: 'flex',
          flexDirection: 'column',
          zIndex: 3,
        }}>
          <span style={{
            fontFamily: FONT_NAME,
            fontWeight: 400,
            fontSize: `calc(${FIGMA.nameSize} * ${scale})`,
            color: p1Active ? '#FFFFFF' : INACTIVE,
          }}>
            {PLAYERS.p1.name}
          </span>
          {introComplete && isOhOneGame && (
            <span style={{
              fontFamily: FONT_NAME,
              fontWeight: 400,
              fontSize: `calc(16 * ${scale})`,
              color: p1Active ? 'rgba(255, 255, 255, 0.6)' : 'rgba(126, 126, 126, 0.6)',
              marginTop: `calc(-4 * ${scale})`,
            }}>
              PPR: {p1DisplayPPR.toFixed(1)}{eightyPercentTriggered ? ' (80%)' : ''}
            </span>
          )}
        </div>
        {/* Score */}
        <span style={{
          position: 'absolute',
          left: `calc(${FIGMA.scoreLeft} * ${scale})`,
          top: '50%',
          transform: 'translateY(-50%)',
          fontFamily: FONT_SCORE,
          fontWeight: 300,
          fontSize: `calc(${FIGMA.scoreSize} * ${scale})`,
          lineHeight: 1,
          color: p1Active ? '#FFFFFF' : INACTIVE,
          textShadow: p1Active ? '-6px 6px 9.7px rgba(0, 0, 0, 0.78)' : 'none',
          zIndex: 3,
        }}>
          {p1Score}
        </span>
      </div>

      {/* Player 2 Bar - Right (mirrored) */}
      <div style={{
        position: 'absolute',
        width: `calc(${FIGMA.bar.w} * ${scale})`,
        height: `calc(${FIGMA.bar.h} * ${scale})`,
        right: '0px',
        bottom: '0px',
        borderTopLeftRadius: `calc(16 * ${scale})`,
        overflow: 'hidden',
      }}>
        {/* Grey base layer - always visible */}
        <div style={{
          position: 'absolute',
          inset: 0,
          background: greyGradient,
        }} />
        {/* Dart progress border - top edge, 1/3 per dart when active, swipes down on exit */}
        {introComplete && p2Active && (
          <div style={{
            position: 'absolute',
            top: 0,
            right: 0,
            height: '3px',
            width: `${(currentDarts.length / 3) * 100}%`,
            background: P2_ACTIVE,
            transition: 'width 0.2s ease-out',
            zIndex: 5,
          }} />
        )}
        {introComplete && p2Exiting && (
          <div key={`p2-progress-exit-${turnKey}`} style={{
            position: 'absolute',
            top: 0,
            right: 0,
            height: '3px',
            width: '100%',
            background: P2_ACTIVE,
            zIndex: 5,
            animation: 'borderDrainDown 0.5s ease-out forwards',
          }} />
        )}
        {/* Colored layer - swipes up when active, swipes down when exiting */}
        {introComplete && (p2Active || p2Exiting) && (
          <div key={`p2-bar-${turnKey}`} style={{
            position: 'absolute',
            inset: 0,
            background: 'linear-gradient(179.4deg, rgba(251, 0, 255, 0.2) 0.52%, rgba(0, 0, 0, 0.2) 95.46%)',
            animation: p2Active ? 'colorSwipeUp 0.5s ease-out forwards' : 'colorSwipeDown 0.5s ease-out forwards',
          }} />
        )}
        {/* Score - on left for P2 */}
        <span style={{
          position: 'absolute',
          left: `calc(20 * ${scale})`,
          top: '50%',
          transform: 'translateY(-50%)',
          fontFamily: FONT_SCORE,
          fontWeight: 300,
          fontSize: `calc(${FIGMA.scoreSize} * ${scale})`,
          lineHeight: 1,
          color: p2Active ? '#FFFFFF' : INACTIVE,
          textShadow: p2Active ? '-6px 6px 9.7px rgba(0, 0, 0, 0.78)' : 'none',
          zIndex: 3,
        }}>
          {p2Score}
        </span>
        {/* Name + PPR - in middle for P2 */}
        <div style={{
          position: 'absolute',
          right: `calc(${FIGMA.nameLeft} * ${scale})`,
          top: '50%',
          transform: 'translateY(-50%)',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'flex-end',
          zIndex: 3,
        }}>
          <span style={{
            fontFamily: FONT_NAME,
            fontWeight: 400,
            fontSize: `calc(${FIGMA.nameSize} * ${scale})`,
            color: p2Active ? '#FFFFFF' : INACTIVE,
          }}>
            {PLAYERS.p2.name}
          </span>
          {introComplete && isOhOneGame && (
            <span style={{
              fontFamily: FONT_NAME,
              fontWeight: 400,
              fontSize: `calc(16 * ${scale})`,
              color: p2Active ? 'rgba(255, 255, 255, 0.6)' : 'rgba(126, 126, 126, 0.6)',
              marginTop: `calc(-4 * ${scale})`,
            }}>
              PPR: {p2DisplayPPR.toFixed(1)}{eightyPercentTriggered ? ' (80%)' : ''}
            </span>
          )}
        </div>
        {/* Avatar - grey base */}
        <div style={{
          position: 'absolute',
          width: `calc(${FIGMA.avatar} * ${scale})`,
          height: `calc(${FIGMA.avatar} * ${scale})`,
          right: `calc(${FIGMA.avatarLeft} * ${scale})`,
          top: '50%',
          transform: 'translateY(-50%)',
          background: '#000000',
          border: `3px solid ${INACTIVE}`,
          borderRadius: '50%',
          zIndex: 1,
        }} />
        {/* Avatar - colored overlay */}
        {introComplete && (p2Active || p2Exiting) && (
          <div key={`p2-avatar-${turnKey}`} style={{
            position: 'absolute',
            width: `calc(${FIGMA.avatar} * ${scale})`,
            height: `calc(${FIGMA.avatar} * ${scale})`,
            right: `calc(${FIGMA.avatarLeft} * ${scale})`,
            top: '50%',
            transform: 'translateY(-50%)',
            background: '#000000',
            border: `3px solid ${P2_ACTIVE}`,
            borderRadius: '50%',
            zIndex: 2,
            animation: p2Active ? 'colorSwipeUp 0.5s ease-out forwards' : 'colorSwipeDown 0.5s ease-out forwards',
          }} />
        )}
      </div>

      {/* Video Feeds - Centered Vertically, Active Player Larger */}
      {introComplete && (
        <>
          {/* P1 Camera - Left Side */}
          <div style={{
            position: 'absolute',
            top: '50%',
            left: `calc(20 * ${scale})`,
            transform: 'translateY(-50%)',
            width: p1Active ? `calc(220 * ${scale})` : `calc(140 * ${scale})`,
            height: p1Active ? `calc(124 * ${scale})` : `calc(79 * ${scale})`,
            background: 'rgba(0, 0, 0, 0.8)',
            borderRadius: `calc(8 * ${scale})`,
            border: `2px solid ${p1Active ? PLAYERS.p1.profilecolor : INACTIVE}`,
            overflow: 'hidden',
            zIndex: 60,
            transition: 'all 0.3s ease-out',
          }}>
            <video
              id="local-video"
              autoPlay
              muted
              playsInline
              style={{
                width: '100%',
                height: '100%',
                objectFit: 'cover',
                transform: 'scaleX(-1)', // Mirror for selfie view
              }}
            />
            {/* Placeholder when no video */}
            <div style={{
              position: 'absolute',
              inset: 0,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontFamily: FONT_NAME,
              fontSize: `calc(12 * ${scale})`,
              color: 'rgba(255, 255, 255, 0.4)',
            }}>
              You
            </div>
          </div>

          {/* P2 Camera - Right Side */}
          <div style={{
            position: 'absolute',
            top: '50%',
            right: `calc(20 * ${scale})`,
            transform: 'translateY(-50%)',
            width: p2Active ? `calc(220 * ${scale})` : `calc(140 * ${scale})`,
            height: p2Active ? `calc(124 * ${scale})` : `calc(79 * ${scale})`,
            background: 'rgba(0, 0, 0, 0.8)',
            borderRadius: `calc(8 * ${scale})`,
            border: `2px solid ${p2Active ? PLAYERS.p2.profilecolor : INACTIVE}`,
            overflow: 'hidden',
            zIndex: 60,
            transition: 'all 0.3s ease-out',
          }}>
            <video
              id="remote-video"
              autoPlay
              playsInline
              style={{
                width: '100%',
                height: '100%',
                objectFit: 'cover',
              }}
            />
            {/* Placeholder when no video */}
            <div style={{
              position: 'absolute',
              inset: 0,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontFamily: FONT_NAME,
              fontSize: `calc(12 * ${scale})`,
              color: 'rgba(255, 255, 255, 0.4)',
            }}>
              Opponent
            </div>
          </div>
        </>
      )}

      {/* Hamburger Menu - Top Right */}
      <div style={{ position: 'absolute', top: `calc(20 * ${scale})`, right: `calc(20 * ${scale})`, zIndex: 100 }}>
        <button
          onClick={() => setMenuOpen(!menuOpen)}
          style={{
            width: `calc(44 * ${scale})`,
            height: `calc(44 * ${scale})`,
            background: 'transparent',
            border: 'none',
            cursor: 'pointer',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            gap: `calc(6 * ${scale})`,
            padding: `calc(8 * ${scale})`,
          }}
        >
          {/* 3 horizontal lines */}
          <span style={{ width: `calc(28 * ${scale})`, height: '3px', background: '#FFFFFF', borderRadius: '2px' }} />
          <span style={{ width: `calc(28 * ${scale})`, height: '3px', background: '#FFFFFF', borderRadius: '2px' }} />
          <span style={{ width: `calc(28 * ${scale})`, height: '3px', background: '#FFFFFF', borderRadius: '2px' }} />
        </button>

        {/* Dropdown Menu */}
        {menuOpen && (
          <div style={{
            position: 'absolute',
            top: `calc(50 * ${scale})`,
            right: 0,
            background: 'rgba(0, 0, 0, 0.8)',
            backdropFilter: 'blur(12px)',
            WebkitBackdropFilter: 'blur(12px)',
            borderRadius: `calc(8 * ${scale})`,
            border: '1px solid rgba(255, 255, 255, 0.1)',
            overflow: 'hidden',
            minWidth: `calc(160 * ${scale})`,
          }}>
            {/* Undo Dart */}
            <button
              onClick={() => {
                handleUndo();
                setMenuOpen(false);
              }}
              disabled={dartHistory.length === 0 || undosRemaining <= 0}
              style={{
                width: '100%',
                padding: `calc(14 * ${scale}) calc(20 * ${scale})`,
                background: 'transparent',
                border: 'none',
                color: (dartHistory.length === 0 || undosRemaining <= 0) ? '#555' : '#FFFFFF',
                fontFamily: FONT_NAME,
                fontSize: `calc(18 * ${scale})`,
                fontWeight: 500,
                textAlign: 'left',
                cursor: (dartHistory.length === 0 || undosRemaining <= 0) ? 'not-allowed' : 'pointer',
                opacity: (dartHistory.length === 0 || undosRemaining <= 0) ? 0.5 : 1,
              }}
              onMouseEnter={(e) => { if (dartHistory.length > 0 && undosRemaining > 0) e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'; }}
              onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
            >
              Undo Dart ({undosRemaining} left)
            </button>
            {/* Leave Game */}
            <button
              onClick={() => {
                setMenuOpen(false);
                onLeaveMatch?.();
              }}
              style={{
                width: '100%',
                padding: `calc(14 * ${scale}) calc(20 * ${scale})`,
                background: 'transparent',
                border: 'none',
                borderTop: '1px solid rgba(255, 255, 255, 0.1)',
                color: '#FF4444',
                fontFamily: FONT_NAME,
                fontSize: `calc(18 * ${scale})`,
                fontWeight: 500,
                textAlign: 'left',
                cursor: 'pointer',
              }}
              onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 68, 68, 0.2)'}
              onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
            >
              Leave Game
            </button>
          </div>
        )}
      </div>

      {/* Achievement Animation Overlay */}
      {activeAnimation && (
        <div style={{
          position: 'absolute',
          inset: 0,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 200,
          pointerEvents: 'none',
        }}>
          {/* Backdrop flash */}
          <div style={{
            position: 'absolute',
            inset: 0,
            background: `radial-gradient(circle, ${PLAYERS[currentThrower].profilecolor}33 0%, transparent 70%)`,
            animation: 'achievementPulse 2s ease-out forwards',
          }} />
          {/* Achievement text */}
          <div style={{
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            fontFamily: FONT_SCORE,
            fontWeight: 300,
            fontSize: `calc(120 * ${scale})`,
            lineHeight: 1,
            color: PLAYERS[currentThrower].profilecolor,
            textShadow: `0 0 30px ${PLAYERS[currentThrower].profilecolor}, 0 0 60px ${PLAYERS[currentThrower].profilecolor}, -4px 4px 8px rgba(0, 0, 0, 0.8)`,
            whiteSpace: 'nowrap',
            animation: 'achievementPulse 2s ease-out forwards, achievementGlow 0.5s ease-in-out infinite',
          }}>
            {ACHIEVEMENT_LABELS[activeAnimation]}
          </div>
        </div>
      )}

      {/* Winners Screen Overlay */}
      {showWinnerScreen && gameWinner && (
        <div style={{
          position: 'absolute',
          inset: 0,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 300,
          background: 'rgba(0, 0, 0, 0.9)',
          animation: 'winnerFadeIn 0.5s ease-out forwards',
        }}>
          {/* Winner glow background */}
          <div style={{
            position: 'absolute',
            inset: 0,
            background: `radial-gradient(circle at center, ${PLAYERS[gameWinner].profilecolor}40 0%, transparent 60%)`,
          }} />

          {/* Match score for medley */}
          {isMedley && (
            <div style={{
              fontFamily: FONT_NAME,
              fontSize: `calc(24 * ${scale})`,
              color: 'rgba(255, 255, 255, 0.5)',
              marginBottom: `calc(10 * ${scale})`,
              animation: 'winnerNameSlide 0.6s ease-out forwards',
              animationDelay: '0.1s',
              opacity: 0,
            }}>
              Game {currentGameIndex + 1} of {matchGames.length} | Match: {p1MatchWins + (gameWinner === 'p1' ? 1 : 0)} - {p2MatchWins + (gameWinner === 'p2' ? 1 : 0)}
            </div>
          )}

          {/* WINNER label - changes for match winner */}
          <div style={{
            fontFamily: FONT_SCORE,
            fontWeight: 300,
            fontSize: `calc(60 * ${scale})`,
            lineHeight: 1,
            color: 'rgba(255, 255, 255, 0.6)',
            letterSpacing: `calc(20 * ${scale})`,
            marginBottom: `calc(20 * ${scale})`,
            animation: 'winnerNameSlide 0.6s ease-out forwards',
            animationDelay: '0.2s',
            opacity: 0,
          }}>
            {matchWinner || (p1MatchWins + (gameWinner === 'p1' ? 1 : 0) >= gamesNeededToWin || p2MatchWins + (gameWinner === 'p2' ? 1 : 0) >= gamesNeededToWin) ? 'MATCH WINNER' : 'GAME WINNER'}
          </div>

          {/* Winner name */}
          <div style={{
            fontFamily: FONT_SCORE,
            fontWeight: 300,
            fontSize: `calc(160 * ${scale})`,
            lineHeight: 1,
            color: PLAYERS[gameWinner].profilecolor,
            textShadow: `0 0 40px ${PLAYERS[gameWinner].profilecolor}, 0 0 80px ${PLAYERS[gameWinner].profilecolor}, -6px 6px 12px rgba(0, 0, 0, 0.8)`,
            animation: 'winnerNameSlide 0.8s ease-out forwards',
            animationDelay: '0.4s',
            opacity: 0,
          }}>
            {PLAYERS[gameWinner].name}
          </div>

          {/* Final score */}
          <div style={{
            fontFamily: FONT_NAME,
            fontSize: `calc(28 * ${scale})`,
            color: 'rgba(255, 255, 255, 0.5)',
            marginTop: `calc(30 * ${scale})`,
            animation: 'winnerNameSlide 0.6s ease-out forwards',
            animationDelay: '0.6s',
            opacity: 0,
          }}>
            Final: {gameWinner === 'p1' ? p1Score : p2Score} - {gameWinner === 'p1' ? p2Score : p1Score}
          </div>

          {/* Button row */}
          <div style={{
            display: 'flex',
            gap: `calc(20 * ${scale})`,
            marginTop: `calc(60 * ${scale})`,
            animation: 'winnerNameSlide 0.6s ease-out forwards',
            animationDelay: '0.8s',
            opacity: 0,
          }}>
            {/* Next Game / Rematch button */}
            {(() => {
              // Check if this win would complete the match
              const wouldCompleteMatch =
                (gameWinner === 'p1' && p1MatchWins + 1 >= gamesNeededToWin) ||
                (gameWinner === 'p2' && p2MatchWins + 1 >= gamesNeededToWin);

              if (isMedley && !wouldCompleteMatch && currentGameIndex < matchGames.length - 1) {
                // Still have games to play - show Next Game
                const nextStarter = getNextGameStarter();

                return (
                  <button
                    onClick={() => {
                      // Direct transition - loser goes first (cork handled externally by CorkScreen component)
                      startNextGame(nextStarter === 'cork' ? 'p1' : nextStarter as 'p1' | 'p2');
                    }}
                    style={{
                      padding: `calc(16 * ${scale}) calc(48 * ${scale})`,
                      fontFamily: FONT_NAME,
                      fontSize: `calc(24 * ${scale})`,
                      fontWeight: 500,
                      color: '#FFFFFF',
                      background: PLAYERS[gameWinner].profilecolor,
                      border: 'none',
                      borderRadius: `calc(12 * ${scale})`,
                      cursor: 'pointer',
                      boxShadow: `0 0 30px ${PLAYERS[gameWinner].profilecolor}80`,
                    }}
                  >
                    Next Game
                  </button>
                );
              } else {
                // Match complete or single game - show Rematch
                return (
                  <button
                    onClick={() => {
                      // Reset everything for full rematch
                      setShowWinnerScreen(false);
                      setGameWinner(null);
                      setMatchGameWinners([]);
                      setCurrentGameIndex(0);
                      setP1Score(301);
                      setP2Score(301);
                      setCurrentDarts([]);
                      setRoundScore(0);
                      setCurrentRound(1);
                      setP1ThrewThisRound(false);
                      setP2ThrewThisRound(false);
                      setP1HasStarted(false);
                      setP2HasStarted(false);
                      setDartHistory([]);
                      setUndosRemaining(3);
                      setCurrentThrower('p1');
                      setShowGoodLuck(true);
                      setIntroComplete(false);
                      // Reset 80% stat tracking
                      setP1DartsThrown(0);
                      setP2DartsThrown(0);
                      setEightyPercentTriggered(false);
                      setP1FrozenPPR(null);
                      setP2FrozenPPR(null);
                    }}
                    style={{
                      padding: `calc(16 * ${scale}) calc(48 * ${scale})`,
                      fontFamily: FONT_NAME,
                      fontSize: `calc(24 * ${scale})`,
                      fontWeight: 500,
                      color: '#FFFFFF',
                      background: PLAYERS[gameWinner].profilecolor,
                      border: 'none',
                      borderRadius: `calc(12 * ${scale})`,
                      cursor: 'pointer',
                      boxShadow: `0 0 30px ${PLAYERS[gameWinner].profilecolor}80`,
                    }}
                  >
                    Rematch
                  </button>
                );
              }
            })()}

            {/* Exit to Lobby button */}
            <button
              onClick={() => {
                setShowWinnerScreen(false);
                setGameWinner(null);
                console.log('Exit to lobby clicked');
              }}
              style={{
                padding: `calc(16 * ${scale}) calc(48 * ${scale})`,
                fontFamily: FONT_NAME,
                fontSize: `calc(24 * ${scale})`,
                fontWeight: 500,
                color: 'rgba(255, 255, 255, 0.7)',
                background: 'transparent',
                border: `2px solid rgba(255, 255, 255, 0.3)`,
                borderRadius: `calc(12 * ${scale})`,
                cursor: 'pointer',
              }}
            >
              Exit to Lobby
            </button>
          </div>
        </div>
      )}

      {/* Dart Simulator Panel - for demo/preview mode */}
      <DartSimulator
        onThrow={throwDart}
        disabled={showPlayerChange || !introComplete || showWinnerScreen || !!activeAnimation}
      />
    </div>
  );
}

export default O1GSPreview;
